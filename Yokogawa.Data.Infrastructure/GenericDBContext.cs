using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Yokogawa.Data.Infrastructure.Entities;
using Yokogawa.Data.Infrastructure.Entities.Base;

namespace Yokogawa.Data.Infrastructure
{
   public class GenericDbContext :DbContext 
    {
        private List<string> _noAuditingFields =new List<string>();
        protected List<string> _tenantFields = new List<string>();

        public GenericDbContext() : base()
        {
        }
        public GenericDbContext(DbContextOptions options) : base(options)
        {
            _noAuditingFields.AddRange(new string [] {  "UpdatedOn", "UpdatedBy", "UpdatedByName", "RowVersion" });

        }
        public DbSet<Audit> Audits { get; set; }

        public int SaveChangesAsync(bool acceptAllChangesOnSuccess)
        {
            var auditEntries = OnBeforeSaveChanges();
            if (auditEntries.Count == 0)
            {
                var result = base.SaveChanges(acceptAllChangesOnSuccess);
                OnAfterSaveChanges(auditEntries);
                return result;
            }
            return -1;
        }

        public override  int SaveChanges(bool acceptAllChangesOnSuccess)
        {
            var auditEntries = OnBeforeSaveChanges();
            var result = base.SaveChanges(acceptAllChangesOnSuccess);
             OnAfterSaveChanges(auditEntries);
            return result;
        }

        public override async Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default(CancellationToken))
        {
            var auditEntries = OnBeforeSaveChanges();
            var result = await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
            await OnAfterSaveChanges(auditEntries);
            return result;
        }

        private List<AuditEntry> OnBeforeSaveChanges()
        {
            ChangeTracker.DetectChanges();
            var auditEntries = new List<AuditEntry>();
            var childAuditEntries = new List<AuditEntry>();
            var entries = ChangeTracker.Entries();
            foreach (var entry in entries)
            {
                //to terminate the computation as early as possible so long as the type is not of auditbale type
                if (!(entry.Entity is IAuditable || entry.Entity is IChild))
                {
                    continue;
                }
                //must be auditable entity which enforce the primary key is Id
                if (entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                    continue;

                var auditEntry = new AuditEntry(entry);
                auditEntry.setTenantFields(_tenantFields);
                auditEntry.TableName = entry.Metadata.GetTableName();
                auditEntry.Action = entry.State == EntityState.Added ? EnumActions.Added : entry.State == EntityState.Modified ? EnumActions.Modified : EnumActions.Deleted;
                foreach (var property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        // value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    string propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues = property.CurrentValue.ToString();
                        continue;
                    }

                    auditEntry.getTenantId(property);

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            auditEntry.NewValues[propertyName] = property.CurrentValue;
                            break;

                        case EntityState.Deleted:              
                            auditEntry.OldValues[propertyName] = property.OriginalValue;
                            break;

                        case EntityState.Modified:
                            {
                                //if(! JsonConvert.SerializeObject(property.OriginalValue).Equals(JsonConvert.SerializeObject(property.CurrentValue)))
                                if (property.IsModified) //property.IsModified is always true if we set the entity state to modified.
                                {
                                    if (!_noAuditingFields.Contains(propertyName))
                                    {
                                      
                                        auditEntry.OldValues[propertyName] = property.OriginalValue;
                                        auditEntry.NewValues[propertyName] = property.CurrentValue;

                                        if (entry.Entity is ISoftDeleteEntity && propertyName == nameof(ISoftDeleteEntity.IsDeleted))
                                        {
                                            var newVal = false;
                                            Boolean.TryParse(property.CurrentValue.ToString(), out newVal);
                                            if(newVal == true)
                                            {
                                                auditEntry.Action = EnumActions.SoftDeleted;
                                            }
                                        }
                                    }
                                }
                            }
                            break;
                    }
                }

                if (entry.Entity is IAuditable)
                {
                    if (!(entry.Entity is IChild))
                    {
                        var auditable = entry.Entity as IAuditable;
                        auditEntry.UserId = auditable.UpdatedOn.HasValue? auditable.UpdatedBy:auditable.CreatedBy;
                        auditEntry.UpdatedOn = auditable.UpdatedOn.HasValue? auditable.UpdatedOn.Value:auditable.CreatedOn;
                        var audit_extenstion = entry.Entity as IAuditableExtension;
                        if (audit_extenstion != null)
                            auditEntry.UserName = audit_extenstion.UpdatedOn.HasValue ? audit_extenstion.UpdatedByName : audit_extenstion.CreatedByName;
                        else
                            auditEntry.UserName = auditEntry.UserId;

                        auditEntries.Add(auditEntry);
                    }
                }

                if (entry.Entity is IChild)
                {
                    childAuditEntries.Add(auditEntry);
                }

                var entity = entry.Entity as IAuditable;
                
                entity.GetValuesForAudit(auditEntry, this);

            }

            if(childAuditEntries.Count>0 && auditEntries.Count>0)
            {
                auditEntries[0].childEntries = childAuditEntries;
            }
            // Save audit entities that have all the modifications
            foreach (var auditEntry in auditEntries.Where(_ => !_.HasTemporaryProperties ))
            {
                Audits.Add(auditEntry.ToAudit());
            }

            // keep a list of entries where the value of some properties are unknown at this step
            return auditEntries.Where(_ => _.HasTemporaryProperties).ToList();
        }

        private Task OnAfterSaveChanges(List<AuditEntry> auditEntries)
        {
            if (auditEntries == null || auditEntries.Count == 0)
                return Task.CompletedTask;
    
            foreach (var auditEntry in auditEntries)
            {
                // Get the final value of the temporary properties
                foreach (var prop in auditEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        // auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                        auditEntry.KeyValues = prop.CurrentValue.ToString();
                    }
                    else
                    {
                        auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // Save the Audit entry
                Audits.Add(auditEntry.ToAudit());
            }
            return SaveChangesAsync();
        }
    }
}
